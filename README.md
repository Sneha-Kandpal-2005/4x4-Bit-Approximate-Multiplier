# 4x4-Bit-Approximate-Multiplier
Traditional multipliers prioritize accuracy, often at the expense of power, speed, or area. 
  
This project implements a low-power, high-speed 4x4-bit approximate multiplier in Verilog HDL by implementing modified Dadda technique, using a combination of approximate compressors, approximate adders, and an exact half-adder. It is suitable for error-resilient applications like image processing or machine learning, where power efficiency and area reduction are more important than perfect accuracy, achieving significant area and power reduction compared to traditional multipliers with minimal minimal absolute error. The design is simulated and synthesized using Xilinx Vivado. 
  
## Overview
An nxn multiplication is conventionally composed of three operational phases: partial product generation, carry-free reduction of partial products and carry propagating addition. In this project, the main focus was on approximation in the partial product tree of approximate multiplier, achieved by reduction in partial product tree. Dadda  technique for multiplication process decreases the number of adder stages. In this techniques half adder and full adders are used for summation of the partial products. Due to this hardware complexity is reduced. 

Multiplication process basically divided in to two steps 
1. Generation of partial products 
2. Reduction in the partial product tree.

## Inputs and Outputs
### Inputs:

A[3:0], B[3:0] — Two 4-bit operands

### Output:

result[7:0] — 8-bit approximate product

![image](https://github.com/user-attachments/assets/60004526-ec97-4e05-8c38-0fb9ece50a99)


## Generation of Partial Product
We considered an 4 bit multiplicand and a 4 bit multiplier. Let us say a is multiplicand and b is the multiplier. 

The mathematical representation of the  multiplicand and multiplier are as follows :

A=A[0]+A[1].2+A[2].2^2+A[3].2^3  
B=B[0]+B[1].2+B[2].2^2+B[3].2^3

Where A[0], A[0] are least significant bits and A[3], B[3] are most significant bits.

Partial product is generated by logical AND operation between Multiplier and Multiplicand bits.

The expression for the partial products of a and b is am,n=A[m].B[n]

## Partial Product Tree
A partial product tree is the structure used to reduce and sum these intermediate terms efficiently.

![image](https://github.com/user-attachments/assets/2a19ef36-94ae-4f40-a32c-c5509e4bc2dd)

The partial products range from 0-15. For summation of all the partial products multiplier requires more number of half and full adders which in deed increase the hardware complexity of the multiplier circuit. So there is need to reduce the partial products in the multiplication process. 

## Propagate and Generate Terms
The reduction in the terms can be done from the stastical point of view. The probability of getting partial product should be 1 is 1/4. Partial products reduction can be done in column wise. 

The partial products  am,n  and an,m are combined together to get propagate term and generate term. The propagate and generate terms are represented as Pm,n and Gm,n. 
The mathematical expressions for Pm,n and Gm,n. are:

Propagate term, Pm,n = am,n or an,m

Generate term, Gm,n= am,n and an,m

The generate signal Gm,n has the probability of being 1/16 which is less than the probability of Pm,n  which is significantly lower than 1/4 of am,n. 

The probability of altered partial product Pm,n being one is 1/16 + 3/16 + 3/16 =7/16, which is higher than Gm,n. These factors are considered, while applying approximation to the altered partial product matrix. 

## Modules Used
Before discussing reduction of partial product tree, it is important to discuss the functionality of certain modules used to calculate sum of reduced columns, which are the different approximation techniques used.

### exact_half_adder
This implements a standard accurate half adder for two bits A and B, calculated as follows:

![image](https://github.com/user-attachments/assets/ed207bce-c508-4def-8bd2-87e17dc42f7e)


where & stands for logical AND and ^ stands for logical XOR operator.

![image](https://github.com/user-attachments/assets/79a333da-5bbe-4000-ad0d-5bbb98384301)

### approx_full_adder
This implementation approximates a full adder for bits A and B with carry C.

![image](https://github.com/user-attachments/assets/ee4305b8-f4aa-4c13-ab73-13d1077cdeb8)

where | stands for logical OR operator.

![image](https://github.com/user-attachments/assets/bf9a238a-ecb2-45c5-9d5e-fd42af29d618)

This results error in 3 cases out of 8 cases. This is significantly less probable to happen because the inputs where this error occurs consist of >=2 terms with 1, which already has probability of occurence as 1/4. 

Total probability of occurence of error:  3.(3/4).(1/4).(1/4)=9/64, which is reltively very small.

### approx_comp_42
This implements a 4:2 compressor, such that it takes in 4 inputs as bits and outputs 2 bits corresponding to sum and carry equivalents of the four bits.

![image](https://github.com/user-attachments/assets/7f15a223-0f9c-4ecb-9cdd-949c56c08794)

![image](https://github.com/user-attachments/assets/49aa8a4c-f604-42de-af06-09227faa913b)

This results in error in 5 out of 16 total cases.

Total probability of occurence of error:  4.(3/4).(3/4).(1/4).(1/4)+(1/4).(1/4).(1/4)=37/256, which is relatively very small.

## Column Wise Reduction and Sum Calculation Algorithm (P[0],...P[7])
The main goal of reduction has been to reduce mean relative error as far as possible. Seeing that the most significant terms matter more in accuracy, the efforts are made to ensure that they are calculated with least approximation. Meanwhile, the least significant bits, having less weight, are the subjects of more approximation owing to their less contribution in error.

### Column 1: P[0]

![image](https://github.com/user-attachments/assets/bc5a65e3-894c-46c6-afc8-246a5ebccf1b)

Product P[0] is simply the partial product term a0,0. It can be directly calculated by simple AND between A[0] and B[0].

### Column 1: P[1]
Product p1 is simply the OR of partial products a0,1 and a1,0. Conventionally, it uses half adder to calculate the carry and sum, as AND and XOR respectively of a0,1 and a1,0. However, P[1] being one of the LSBs can be approximated due to its low contribution to error. 

![image](https://github.com/user-attachments/assets/5e82d9b7-058f-4f43-99fd-df1d9db73cce)

For two bit sum, XOR and OR operation yield same results, resulting in accurate prediction of p1. XOR increases delay and hardware complexity, hence replacement with OR operator greatly increases speed and reduces hardware2

However, carry term is neglected in the calculation. However, this yield incorrect result in only 1 out of 16 total combinations of A[0],B[0],A[1],B[1] (this happens only when all four are equal to one, with each being equal to one with probability 1/2). Thus, relatively lesser error happens as effect of forward carry can be ignored in 15 out of 16 cases. 

### Column 2: P[2]

Here, with the help of approximate compressor designed earlier, the sum (P[2]) and forward carry (C2) for next column were calculated, with partial products a2,2, a3,1, a1,3 as 3 inputs. The carry from previous column, as discussed above, is treated as 0. Thus, the fourth input becomes 0. This further reduces complexity and improves speed.

This approximation is not valid (forward carry = 0) in further columns due to considerations of accuracy.

![image](https://github.com/user-attachments/assets/7dea9c17-7c61-43af-a365-6a457d210bc5)


### Column 3: P[3]

![image](https://github.com/user-attachments/assets/6097cf6f-106a-4c2c-9615-8be4492d6b19)

This column is of significant interest because of highest number of partial products in this column. We have 5 bits to add: four partial products a0,3, a3,0, a1,2, a2,1 and the carry C2 from the previous column. The net approximate sum would yield P[3] and C3 as the forward carry to the next column.

Here, the concept of propagate and generate terms comes handy. Apparently, the two partial products am,n and an,m can be replaced by Gm,n and Pm,n, i.e.,

am,n + an,m = Gm,n + Pm,n

![image](https://github.com/user-attachments/assets/67b59d8e-bc5a-481a-a7e6-39773467510f)

This yields error in only 1 out of 4 cases, with total probability of error being (1/2).(1/2).(1/2).(1/2)=1/16.

Thus, we now end up with C2 and

-> P0,3 = A[3] & B[0]) | (A[0] & B[3])

-> P1,2 = (A[2] & B[1]) | (A[1] & B[2])

-> G0,3 = (A[0] & B[3] & A[3] & B[0])

-> G1,2 = A[1] & B[2] & A[2] & B[1])

as inputs.

We further reduce the terms G0,3 and G1,2 to their propagate and generate terms, leaving us with two other terms instead of G0,3 and G1,2:

-> P0,1,2,3 = (A[0] & B[3] & A[3] & B[0]) |  (A[1] & B[2] & A[2] & B[1])

-> G0,1,2,3 = (A[0] & B[3] & A[3] & B[0]) &  (A[1] & B[2] & A[2] & B[1])

Now, probability of G0,1,2,3 being 1 is equal to (1/2).(1/2).(1/2).(1/2).(1/2).(1/2).(1/2).(1/2)=1/256, which means this can be safely approximated to 0 (only one case out of total 256 cases would face error, which is a very reasonable approximation).

Thus, with G0,1,2,3 equated to 0, we end up with inputs P0,3, P1,2, P0,1,2,3 and C2 as inputs to the approximate compressor discussed before to give P[3] as sum and C3 as forward carry to next column.

### Column 4: P[4]
With the help of approximate compressor designed earlier, the sum (P[4]) and forward carry (C4) for next column were calculated, with partial products a2,2, a3,1, a1,3 and the carry C3 from previous column as inputs.

![image](https://github.com/user-attachments/assets/76a1f0f5-7760-445d-95b9-45b2bf97d57a)


### Column 5: P[5]

With the help of approximate full adder designed earlier, the sum (P[5]) and forward carry (C5) for next column were calculated, with partial products a2,3, a3,2 and the carry C4 from previous column as inputs.

![image](https://github.com/user-attachments/assets/9b1cdde0-7a4e-4b61-a83d-56f5a0cfd741)


### Columns 6 and 7: P[6] and P[7]

To maintain higher accuracy and keeping in mind the importance of accuracy in MSBs for obtaining lower mean relative error, an exact half adder was used, with a3,3 and the previous carray C5 as inputs to the exact half adder. This replaced P[6] with sum of the two bits (XOR) and P[7] as the carry hence obtained (AND).

![image](https://github.com/user-attachments/assets/ea623b0e-4c24-4be0-810c-26eeebd00018)


## Results
### Mean Absolute Error:

![image](https://github.com/user-attachments/assets/05ff45a8-443e-4553-bf02-c416095730d6)

Mean Relative Error: 6.24%

### Utilisation Report:
![image](https://github.com/user-attachments/assets/b721066a-b8aa-40a4-994e-ad0f7fc562a9)

![image](https://github.com/user-attachments/assets/371835b2-7e48-4a26-bcd6-27ac828c802d)

Number of LUTs used: 10 (significantly lower than 16 LUTs used by conventional multiplier.

### Power Report:
![image](https://github.com/user-attachments/assets/3ff4f4d3-71f0-4e25-91c9-abbff397d5b1)

![image](https://github.com/user-attachments/assets/f2f25762-6725-4bfd-85ca-b04e3c39c585)

![image](https://github.com/user-attachments/assets/3acfac6f-3c65-4368-8ca4-4ab0085c53a5)

![image](https://github.com/user-attachments/assets/8dcf3b03-adfb-422a-af43-a1e8ae2e7480)


## Conclusion
This design trades off some accuracy (6.24% mean relative error) for gains in:

  -> Area efficiency (LUTs reduced from 16 to 12).
  
  -> Reduced power consumption
  
  -> Improved delay (speed) 
